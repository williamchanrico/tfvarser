package tfvars

import (
	"errors"
	"io"
	"os"
	"path"
	"text/template"
)

// Generator  for packages that want to produce tfvars file
type Generator interface {
	Name() string
	Kind() string
	Template() string
	Execute(io.Writer, *template.Template) error
}

// Service struct maps provider+object to its corresponding generator/template
type Service struct {
	generator map[string]Generator
	tmpl      map[string]*template.Template
}

// New return new tfvars generator
func New(gens ...Generator) *Service {
	tfvarsGenerator := make(map[string]Generator)
	tfvarsTmpl := make(map[string]*template.Template)

	for _, generator := range gens {
		tfvarsGenerator[generator.Name()] = generator

		// Only parse the same template once
		if _, ok := tfvarsTmpl[generator.Kind()]; !ok {
			tmpl := template.Must(template.New(generator.Name()).Parse(generator.Template()))
			tfvarsTmpl[generator.Name()] = tmpl
		}
	}

	return &Service{
		generator: tfvarsGenerator,
		tmpl:      tfvarsTmpl,
	}
}

// Generate a tmpl from initialized Generator (name is a concat of provider+object)
func (s *Service) Generate(generatorName, dir, filename string) error {
	var ok bool
	var err error

	var generator Generator
	if generator, ok = s.generator[generatorName]; !ok {
		return errors.New("Generator not found: " + generatorName)
	}

	var tmpl *template.Template
	if tmpl, ok = s.tmpl[generatorName]; !ok {
		return errors.New("Tmpl not found: " + generatorName)
	}

	err = makeDirIfNotExists(dir)
	if err != nil {
		return err
	}

	f, err := os.Create(path.Join(dir, filename))
	defer f.Close()
	if err != nil {
		return err
	}

	return generator.Execute(f, tmpl)
}
